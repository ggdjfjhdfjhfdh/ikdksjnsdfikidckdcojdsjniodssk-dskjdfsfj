---
export interface Props {
  steps: Array<{
    title: string;
    description: string;
    icon?: string;
    duration?: string;
  }>;
}

const { steps } = Astro.props;
---

<div class="timeline">
  <div class="timeline-line" id="timeline-line"></div>
  
  {steps.map((step, index) => (
    <div class={`timeline-item fade-in stagger-${index + 1}`} data-step={index}>
      <div class="timeline-marker">
        <div class="timeline-dot">
          <svg class="timeline-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            {index === 0 && (
              <!-- Recon -->
              <>
                <circle cx="11" cy="11" r="8"/>
                <path d="M21 21l-4.35-4.35"/>
              </>
            )}
            {index === 1 && (
              <!-- Pentest -->
              <>
                <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
                <path d="M9 12l2 2 4-4"/>
              </>
            )}
            {index === 2 && (
              <!-- Implementación -->
              <>
                <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/>
              </>
            )}
            {index === 3 && (
              <!-- Mantenimiento -->
              <>
                <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/>
                <circle cx="12" cy="12" r="1"/>
              </>
            )}
          </svg>
        </div>
      </div>
      
      <div class="timeline-content">
        <div class="timeline-header">
          <h3 class="timeline-title">{step.title}</h3>
          {step.duration && (
            <span class="timeline-duration">{step.duration}</span>
          )}
        </div>
        <p class="timeline-description">{step.description}</p>
      </div>
    </div>
  ))}
</div>

<script>
  // Animación del timeline al hacer scroll
  document.addEventListener('DOMContentLoaded', function() {
    const timelineLine = document.getElementById('timeline-line');
    const timelineItems = document.querySelectorAll('.timeline-item');
    
    // Iniciar animación de la línea
    setTimeout(() => {
      timelineLine.classList.add('animate');
    }, 300);
    
    // Observador de intersección para animar items al hacer scroll
    const observerOptions = {
      threshold: 0.3,
      rootMargin: '0px 0px -100px 0px'
    };
    
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('active');
          
          // Animar el número de paso
          const stepNumber = entry.target.getAttribute('data-step');
          if (stepNumber !== null) {
            const stepElement = entry.target;
            stepElement.style.setProperty('--step-pulse', '1');
            
            setTimeout(() => {
              stepElement.style.setProperty('--step-pulse', '0');
            }, 1000);
          }
        }
      });
    }, observerOptions);
    
    timelineItems.forEach(item => {
      observer.observe(item);
    });
    
    // Efecto hover mejorado
    timelineItems.forEach(item => {
      item.addEventListener('mouseenter', () => {
        const step = item.getAttribute('data-step');
        const allItems = document.querySelectorAll('.timeline-item');
        
        allItems.forEach(otherItem => {
          if (otherItem !== item) {
            otherItem.style.opacity = '0.6';
            otherItem.style.transform = 'scale(0.98)';
          }
        });
        
        item.style.zIndex = '10';
      });
      
      item.addEventListener('mouseleave', () => {
        const allItems = document.querySelectorAll('.timeline-item');
        
        allItems.forEach(otherItem => {
          otherItem.style.opacity = '1';
          otherItem.style.transform = '';
        });
        
        item.style.zIndex = '';
      });
    });
  });
</script>

<script>
  // Animación de la línea de tiempo
  class TimelineAnimation {
    timeline: Element | null;
    items: NodeListOf<Element>;
    observer: IntersectionObserver | null;
    
    constructor() {
      this.timeline = document.querySelector('.timeline-line');
      this.items = document.querySelectorAll('.timeline-item');
      this.observer = null;
      
      if (this.timeline && this.items.length > 0) {
        this.init();
      }
    }
    
    init() {
      // Configurar Intersection Observer
      this.observer = new IntersectionObserver(
        (entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              entry.target.classList.add('active');
              this.updateTimelineLine();
            }
          });
        },
        {
          threshold: 0.5,
          rootMargin: '-50px 0px'
        }
      );
      
      // Observar cada item del timeline
      this.items.forEach(item => {
        this.observer.observe(item);
      });
    }
    
    updateTimelineLine() {
      const activeItems = document.querySelectorAll('.timeline-item.active');
      const progress = activeItems.length / this.items.length;
      
      if (progress > 0 && this.timeline) {
        (this.timeline as HTMLElement).classList.add('animate');
        (this.timeline as HTMLElement).style.setProperty('--progress', `${progress * 100}%`);
      }
    }
    
    destroy() {
      if (this.observer) {
        this.observer.disconnect();
      }
    }
  }
  
  // Inicializar animación
  let timelineAnimation = null;
  
  if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
    timelineAnimation = new TimelineAnimation();
  }
  
  // Cleanup al cambiar de página
  document.addEventListener('astro:before-swap', () => {
    if (timelineAnimation) {
      timelineAnimation.destroy();
    }
  });
</script>